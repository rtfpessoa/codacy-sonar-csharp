This rule raises if you acquire a lock with one of the following methods, and do not release it within the same method.

- [ReaderWriterLock.AcquireReaderLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock.acquirereaderlock)
- [ReaderWriterLock.AcquireWriterLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock.acquirewriterlock)
- [ReaderWriterLockSlim.EnterReadLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.enterreadlock)
- [ReaderWriterLockSlim.EnterUpgradeableReadLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.enterupgradeablereadlock)
- [ReaderWriterLockSlim.TryEnterReadLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.tryenterreadlock)
- [ReaderWriterLockSlim.TryEnterUpgradeableReadLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.tryenterupgradeablereadlock)
- [ReaderWriterLockSlim.EnterWriteLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.enterwritelock)
- [ReaderWriterLockSlim.TryEnterWriteLock](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.tryenterwritelock)
- [SpinLock.Enter](https://learn.microsoft.com/en-us/dotnet/api/system.threading.spinlock.enter)
- [SpinLock.TryEnter](https://learn.microsoft.com/en-us/dotnet/api/system.threading.spinlock.tryenter)

This rule will raise an issue when the code uses the [disposable pattern](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose). This pattern makes locking
easy to use and delegates the responsibility to the caller. Users should accept issues in such cases, as they should appear only once for each
synchronization type.

## Why is this an issue?

Not releasing a lock in the same method where you acquire it, and releasing in another one, makes the code less clear and harder to maintain. You
are also introducing the risk of not releasing a lock at all which can lead to deadlocks or exceptions.

### Code examples

#### Noncompliant code example

    public class Example
    {
        private static ReaderWriterLock rwLock = new();
    
        public void AcquireWriterLock() =>
            rwLock.AcquireWriterLock(2000);  // Noncompliant, as the lock release is on the callers responsibility
    
        public void DoSomething()
        {
            // ...
        }
    
        public void ReleaseWriterLock() =>
            rwLock.ReleaseWriterLock();
    }

#### Compliant solution

    public class Example
    {
        private static ReaderWriterLock rwLock = new();
    
        public void DoSomething()
        {
            rwLock.AcquireWriterLock(2000); // Compliant, locks are released in the same method
            try
            {
                // ...
            }
            finally
            {
                rwLock.ReleaseWriterLock();
            }
        }
    }

## Resources

### Documentation

- Microsoft Learn - [ReaderWriterLock Class](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock)
- Microsoft Learn - [ReaderWriterLockSlim Classs](https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim)
- Microsoft Learn - [SpinLock Struct](https://learn.microsoft.com/en-us/dotnet/api/system.threading.spinlock)